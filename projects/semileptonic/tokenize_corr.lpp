%option noyywrap
%option prefix="two_pts_corr_parser_"
%option outfile="tokenize_corr.cpp"
%option reentrant
%option bison-bridge
%option bison-locations

%{
#include <stdio.h>
#include "../../src/nissa.h"
#include "driver_corr.hpp"

#define CORR_NAME yyextra->corr_name[yyextra->ncorr]   
#define YY_EXTRA_TYPE two_pts_parser_driver*
   
#define YY_INPUT(buf,result,max_size)		\
   {						\
     char c;					\
     fscanf(yyextra->fin,"%c",&c);		\
     if(feof(yyextra->fin)) result=YY_NULL;	\
     else					\
       {					\
	 result=1;				\
	 buf[0]=c;				\
       }					\
   }
   
#include "parse_corr.hpp"
   
   const int debug_lexer=0;
%}

%%
 /* ignoring rules */
\/\/[[:alnum:][:blank:]^+-/=*()\n]* if(debug_lexer) printf("Ignoring comment: %s\n",yytext);
[[:blank:]]+ if(debug_lexer) printf("Ignoring spaces: \"%s\"\n",yytext);
^[[:blank:]]+\n+ if(debug_lexer) printf("Ignoring new line at the begin of a line\n");

 /* incrementing icorr */
\n* yyextra->ncorr++;if(debug_lexer) printf("Incrementing icorr: %d\n",yyextra->ncorr); return ENDL;

 /* operators */
\+ CORR_NAME+="+"; return '+';
-  CORR_NAME+="-"; return '-';
\( CORR_NAME+="("; return '(';
\) CORR_NAME+=")"; return ')';
\* CORR_NAME+="*"; return '*';
\/ CORR_NAME+="/"; return '/';

 /* real or imaginary */
Re if(debug_lexer) printf("Found Re\n"); CORR_NAME+="Re"; return REAL_CORR;
Im if(debug_lexer) printf("Found Im\n"); CORR_NAME+="Im"; return IMAG_CORR;

 /* recognizing interpolators */
(S|S0)  if(debug_lexer) printf("Found S0\n"); CORR_NAME+="S0"; yylval->interpolator=0; return INTERPOLATOR;
(V1)    if(debug_lexer) printf("Found V1\n"); CORR_NAME+="V1"; yylval->interpolator=1; return INTERPOLATOR;
(V2)    if(debug_lexer) printf("Found V2\n"); CORR_NAME+="V2"; yylval->interpolator=2; return INTERPOLATOR;
(V3)    if(debug_lexer) printf("Found V3\n"); CORR_NAME+="V3"; yylval->interpolator=3; return INTERPOLATOR;
(V4|V0) if(debug_lexer) printf("Found V4\n"); CORR_NAME+="V0"; yylval->interpolator=4; return INTERPOLATOR;
(P|P5)  if(debug_lexer) printf("Found P5\n"); CORR_NAME+="P5"; yylval->interpolator=5; return INTERPOLATOR;
(A1)    if(debug_lexer) printf("Found A1\n"); CORR_NAME+="A1"; yylval->interpolator=6; return INTERPOLATOR;
(A2)    if(debug_lexer) printf("Found A2\n"); CORR_NAME+="A2"; yylval->interpolator=7; return INTERPOLATOR;
(A3)    if(debug_lexer) printf("Found A3\n"); CORR_NAME+="A3"; yylval->interpolator=8; return INTERPOLATOR;
(A4|A0) if(debug_lexer) printf("Found A4\n"); CORR_NAME+="A0"; yylval->interpolator=9; return INTERPOLATOR;
(T1)    if(debug_lexer) printf("Found T1\n"); CORR_NAME+="T1"; yylval->interpolator=10;return INTERPOLATOR;
(T2)    if(debug_lexer) printf("Found T2\n"); CORR_NAME+="T2"; yylval->interpolator=11;return INTERPOLATOR;
(T3)    if(debug_lexer) printf("Found T3\n"); CORR_NAME+="T3"; yylval->interpolator=12;return INTERPOLATOR;
(B1)    if(debug_lexer) printf("Found B1\n"); CORR_NAME+="B1"; yylval->interpolator=13;return INTERPOLATOR;
(B2)    if(debug_lexer) printf("Found B2\n"); CORR_NAME+="B2"; yylval->interpolator=14;return INTERPOLATOR;
(B3)    if(debug_lexer) printf("Found B3\n"); CORR_NAME+="B3"; yylval->interpolator=15;return INTERPOLATOR;

 /* recognizing numbers */
([0-9]*\.[0-9]+)|([0-9]+\.[0-9]*|([0-9]+)) if(debug_lexer) printf("Found DOUBLE: %s\n",yytext);sscanf(yytext,"%lg",&yylval->double_numb); CORR_NAME+=yytext; return DOUBLE_NUMB;

%%

//initializator
two_pts_parser_driver::two_pts_parser_driver(const char *path)
{
  //open file                                                                                                            
  fin=fopen(path,"r");
  if(fin==NULL) crash("opening %s",path);

  //reset corr
  ncorr=0;

  init_scanner();
}

//initialize the scanner
void two_pts_parser_driver::init_scanner()
{
  yylex_init(&scanner);
  yyset_extra(this,scanner);
}

//destroy the scanner
void two_pts_parser_driver::destroy_scanner()
{
  yylex_destroy(scanner);
}

//read a list of two pts
two_pts_comp_t read_two_pts_sink_source_corr_from_file(const char *path)
{
  two_pts_parser_driver driver(path);
  two_pts_corr_parser_parse(&driver);
  
  //internal ncorr is wrong
  driver.output.corr_name=driver.corr_name;
  driver.output.ncorr=driver.ncorr;
  
  return driver.output;
}
